""" This example demonstrates how to use the FMU.get*() and FMU.set*() functions
 to set custom input and control the simulation """

import os
from fmpy import read_model_description, extract
from fmpy.fmi2 import FMU2Slave
from fmpy.util import plot_result
# import numpy as np
import shutil
import time as checktime;
import clr
from System import *
from System.Collections.Generic import *

class FMI_manager:

    isInit = False
    current_time = 0.0
    
    def __init__(self, path, start_time = 0.0, step_size = 0.001) -> None:
        self.path = path
        self.start_time = start_time
        self.step_size = step_size
        self.full_path = (path).replace('\\','/')

        # read the model description
        self.model_description = read_model_description(self.full_path)

        # collect the value references
        self.vrs = {}
        for variable in self.model_description.modelVariables:
            self.vrs[variable.name] = variable.valueReference

        # print(self.vrs)

    def simulate_init(self):
        if not self.isInit:
            # extract the FMU
            self.unzipdir = extract(self.full_path)

            self.fmu = FMU2Slave(guid=self.model_description.guid,
                            unzipDirectory=self.unzipdir,
                            modelIdentifier=self.model_description.coSimulation.modelIdentifier,
                            instanceName='instane1')

            # initialize
            self.fmu.instantiate()
            self.fmu.setupExperiment(startTime=self.start_time)
            self.fmu.enterInitializationMode()
            self.fmu.exitInitializationMode()

            self.isInit = True

    def simulate_init_set(self, set_key, set_value):
        if not self.isInit:
            # extract the FMU
            self.unzipdir = extract(self.full_path)

            self.fmu = FMU2Slave(guid=self.model_description.guid,
                            unzipDirectory=self.unzipdir,
                            modelIdentifier=self.model_description.coSimulation.modelIdentifier,
                            instanceName='instane1')

            # initialize
            self.fmu.instantiate()


            self.fmu.setupExperiment(startTime=self.start_time)
            self.fmu.enterInitializationMode()
            self.fmu.setReal(set_key, set_value)
            self.fmu.exitInitializationMode()

            self.isInit = True

    def simulate_free(self):
        if self.isInit:
            # free fmi instance
            self.fmu.terminate()
            self.fmu.freeInstance()

            # clean up
            shutil.rmtree(self.unzipdir, ignore_errors=True)
            self.unzipdir = str()
            self.current_time = 0.0

            self.isInit = False

    def simulate_step(self, step_time, set_key, set_value, key_get):
        #start = checktime.time()
        if not self.isInit: self.simulate_init()

        time = self.current_time
        self.fmu.setReal(set_key, set_value)

        # perform one step
        self.fmu.doStep(currentCommunicationPoint=time, communicationStepSize=step_time)
        self.current_time += step_time

        list_return = List[Double]()

        for i in key_get:
            list_return.Add(self.fmu.getReal([i])[0])
        #end = checktime.time()    
        #print(f"{end - start:.5f} sec")
        return list_return

    def get_vrs(self):
        result = Dictionary[String, Int32]()
        for key, value in self.vrs.items():
            result.Add(key,value)
        return result

    def simulate_custom_input(self, show_plot=False, stop_time = 10.0):
        
        # get the value references for the variables we want to get/set
        vr_mass   = self.vrs['mass.m']
        vr_damper   = self.vrs['springDamper.d']
        vr_outputs4 = self.vrs['mass.s']

        self.simulate_init()

        time = self.start_time

        rows = []  # list to record the results
        list_return = List[Array[Double]]()

        # simulation loop
        while time < stop_time:

            # NOTE: the FMU.get*() and FMU.set*() functions take lists of
            # value references as arguments and return lists of values

            # set the input
            self.fmu.setReal([vr_damper], [5.0 if time > 5 else 1.00])
            self.fmu.setReal([vr_mass], [1])
            

            # perform one step
            self.fmu.doStep(currentCommunicationPoint=time, communicationStepSize=self.step_size)

            # get the values for 'mass' and 'outputs[4]'
            mass, outputs4 = self.fmu.getReal([vr_mass, vr_outputs4])
            damper_value = self.fmu.getReal([vr_damper])

            # use the threshold to terminate the simulation
            '''
            if outputs4 > threshold:
                print("Threshold reached at t = %g s" % time)
                break
            '''
            # append the results
            # rows.append((time, mass, outputs4))
            # rows.append((time, damper_value[0]))
            # rows.append((time, damper_value[0], outputs4))
            rows.append((time, damper_value[0], mass, outputs4))
            list_return.Add((time, damper_value[0], mass, outputs4))

            # advance the time
            time += self.step_size

        self.simulate_free()

        # convert the results to a structured NumPy array
        # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('mass', np.float64), ('damper', np.float64)]))
        # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('damper', np.float64)]))
        # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('damper', np.float64), ('mass', np.float64), ('s', np.float64)]))

        # plot the results
        if show_plot:
            plot_result(result)

        return list_return


if __name__ == '__main__':
    
    #FMI = FMI_manager(os.getcwd() + '\\fmu\\'+'Vehicle.fmu')
    FMI = FMI_manager(os.getcwd() + '\\test.fmu')

    FMI.simulate_init()

    print(FMI.vrs)
    # vr_mass = FMI.vrs['mass.m']
    # vr_damper = FMI.vrs['springDamper.d']

    # set_dic = dict([[vr_damper, 5.0 if FMI.current_time > 5 else 1.00], [vr_mass, 1]])
    
    rows = []

    while FMI.current_time < 10.0:

        set_key = [vr_mass, vr_damper]
        set_value = [1, 5.0 if FMI.current_time > 5 else 1.00]
        get_key = [FMI.vrs['mass.s']]

        aa = FMI.simulate_step(0.01, set_key, set_value, get_key)
        row = [FMI.current_time]
        row.extend(set_value)
        row.extend(aa)
        rows.append(tuple(row))
    
    FMI.simulate_free()

    # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('mass', np.float64), ('damper', np.float64), ('s', np.float64)]))
    # plot_result(result)



    
def simulate_custom_input(show_plot=False):

    # define the model name and simulation parameters
    #fmu_filename = 'CoupledClutches.fmu'
    path = os.getcwd() + '\\fmu\\'
    fmu_filename = 'test.fmu'
    full_path = (path + fmu_filename).replace('\\','/')    

    start_time = 0.0
    threshold = 3.0
    stop_time = 10.0
    step_size = 0.01

    # download the FMU
    # download_test_file('2.0', 'CoSimulation', 'MapleSim', '2016.2', 'CoupledClutches', fmu_filename)

    # read the model description
    model_description = read_model_description(full_path)

    # collect the value references
    vrs = {}
    for variable in model_description.modelVariables:
        vrs[variable.name] = variable.valueReference

    print(vrs)
    
    # get the value references for the variables we want to get/set
    vr_mass   = vrs['mass.m']
    vr_damper   = vrs['springDamper.d']
    vr_outputs4 = vrs['mass.s']

    # extract the FMU
    unzipdir = extract(full_path)

    fmu = FMU2Slave(guid=model_description.guid,
                    unzipDirectory=unzipdir,
                    modelIdentifier=model_description.coSimulation.modelIdentifier,
                    instanceName='instane1')

    # initialize
    fmu.instantiate()
    fmu.setupExperiment(startTime=start_time)
    fmu.enterInitializationMode()
    fmu.exitInitializationMode()

    time = start_time

    rows = []  # list to record the results
    list_return = List[Array[Double]]()

    # simulation loop
    while time < stop_time:

        # NOTE: the FMU.get*() and FMU.set*() functions take lists of
        # value references as arguments and return lists of values

        # set the input
        fmu.setReal([vr_damper], [5.0 if time > 5 else 1.00])
        fmu.setReal([vr_mass], [1])
        

        # perform one step
        fmu.doStep(currentCommunicationPoint=time, communicationStepSize=step_size)

        # get the values for 'mass' and 'outputs[4]'
        mass, outputs4 = fmu.getReal([vr_mass, vr_outputs4])
        damper_value = fmu.getReal([vr_damper])

        # use the threshold to terminate the simulation
        '''
        if outputs4 > threshold:
            print("Threshold reached at t = %g s" % time)
            break
        '''
        # append the results
        # rows.append((time, mass, outputs4))
        # rows.append((time, damper_value[0]))
        # rows.append((time, damper_value[0], outputs4))
        rows.append((time, damper_value[0], mass, outputs4))
        list_return.Add((time, damper_value[0], mass, outputs4))
        

        # advance the time
        time += step_size

    fmu.terminate()
    fmu.freeInstance()

    # clean up
    shutil.rmtree(unzipdir, ignore_errors=True)

    # convert the results to a structured NumPy array
    # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('mass', np.float64), ('damper', np.float64)]))
    # result = np.array(rows, dtype=np.dtype([('time', np.float64), ('damper', np.float64)]))
    #result = np.array(rows, dtype=np.dtype([('time', np.float64), ('damper', np.float64), ('mass', np.float64), ('s', np.float64)]))



    # plot the results
    #if show_plot:
    #    plot_result(result)

    return list_return


    
